// Code generated by counterfeiter. DO NOT EDIT.
package handlerfakes

import (
	"context"
	"sync"

	"code.cloudfoundry.org/eirini/handler"
	"code.cloudfoundry.org/eirini/models/cf"
)

type FakeTaskBifrost struct {
	CancelTaskStub        func(context.Context, string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	GetTaskStub        func(context.Context, string) (cf.TaskResponse, error)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getTaskReturns struct {
		result1 cf.TaskResponse
		result2 error
	}
	getTaskReturnsOnCall map[int]struct {
		result1 cf.TaskResponse
		result2 error
	}
	ListTasksStub        func(context.Context) (cf.TasksResponse, error)
	listTasksMutex       sync.RWMutex
	listTasksArgsForCall []struct {
		arg1 context.Context
	}
	listTasksReturns struct {
		result1 cf.TasksResponse
		result2 error
	}
	listTasksReturnsOnCall map[int]struct {
		result1 cf.TasksResponse
		result2 error
	}
	TransferTaskStub        func(context.Context, string, cf.TaskRequest) error
	transferTaskMutex       sync.RWMutex
	transferTaskArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 cf.TaskRequest
	}
	transferTaskReturns struct {
		result1 error
	}
	transferTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTaskBifrost) CancelTask(arg1 context.Context, arg2 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CancelTaskStub
	fakeReturns := fake.cancelTaskReturns
	fake.recordInvocation("CancelTask", []interface{}{arg1, arg2})
	fake.cancelTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskBifrost) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeTaskBifrost) CancelTaskCalls(stub func(context.Context, string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeTaskBifrost) CancelTaskArgsForCall(i int) (context.Context, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskBifrost) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskBifrost) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskBifrost) GetTask(arg1 context.Context, arg2 string) (cf.TaskResponse, error) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1, arg2})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskBifrost) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeTaskBifrost) GetTaskCalls(stub func(context.Context, string) (cf.TaskResponse, error)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeTaskBifrost) GetTaskArgsForCall(i int) (context.Context, string) {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTaskBifrost) GetTaskReturns(result1 cf.TaskResponse, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 cf.TaskResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskBifrost) GetTaskReturnsOnCall(i int, result1 cf.TaskResponse, result2 error) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 cf.TaskResponse
			result2 error
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 cf.TaskResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskBifrost) ListTasks(arg1 context.Context) (cf.TasksResponse, error) {
	fake.listTasksMutex.Lock()
	ret, specificReturn := fake.listTasksReturnsOnCall[len(fake.listTasksArgsForCall)]
	fake.listTasksArgsForCall = append(fake.listTasksArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListTasksStub
	fakeReturns := fake.listTasksReturns
	fake.recordInvocation("ListTasks", []interface{}{arg1})
	fake.listTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskBifrost) ListTasksCallCount() int {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	return len(fake.listTasksArgsForCall)
}

func (fake *FakeTaskBifrost) ListTasksCalls(stub func(context.Context) (cf.TasksResponse, error)) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = stub
}

func (fake *FakeTaskBifrost) ListTasksArgsForCall(i int) context.Context {
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	argsForCall := fake.listTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskBifrost) ListTasksReturns(result1 cf.TasksResponse, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	fake.listTasksReturns = struct {
		result1 cf.TasksResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskBifrost) ListTasksReturnsOnCall(i int, result1 cf.TasksResponse, result2 error) {
	fake.listTasksMutex.Lock()
	defer fake.listTasksMutex.Unlock()
	fake.ListTasksStub = nil
	if fake.listTasksReturnsOnCall == nil {
		fake.listTasksReturnsOnCall = make(map[int]struct {
			result1 cf.TasksResponse
			result2 error
		})
	}
	fake.listTasksReturnsOnCall[i] = struct {
		result1 cf.TasksResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeTaskBifrost) TransferTask(arg1 context.Context, arg2 string, arg3 cf.TaskRequest) error {
	fake.transferTaskMutex.Lock()
	ret, specificReturn := fake.transferTaskReturnsOnCall[len(fake.transferTaskArgsForCall)]
	fake.transferTaskArgsForCall = append(fake.transferTaskArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 cf.TaskRequest
	}{arg1, arg2, arg3})
	stub := fake.TransferTaskStub
	fakeReturns := fake.transferTaskReturns
	fake.recordInvocation("TransferTask", []interface{}{arg1, arg2, arg3})
	fake.transferTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskBifrost) TransferTaskCallCount() int {
	fake.transferTaskMutex.RLock()
	defer fake.transferTaskMutex.RUnlock()
	return len(fake.transferTaskArgsForCall)
}

func (fake *FakeTaskBifrost) TransferTaskCalls(stub func(context.Context, string, cf.TaskRequest) error) {
	fake.transferTaskMutex.Lock()
	defer fake.transferTaskMutex.Unlock()
	fake.TransferTaskStub = stub
}

func (fake *FakeTaskBifrost) TransferTaskArgsForCall(i int) (context.Context, string, cf.TaskRequest) {
	fake.transferTaskMutex.RLock()
	defer fake.transferTaskMutex.RUnlock()
	argsForCall := fake.transferTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTaskBifrost) TransferTaskReturns(result1 error) {
	fake.transferTaskMutex.Lock()
	defer fake.transferTaskMutex.Unlock()
	fake.TransferTaskStub = nil
	fake.transferTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskBifrost) TransferTaskReturnsOnCall(i int, result1 error) {
	fake.transferTaskMutex.Lock()
	defer fake.transferTaskMutex.Unlock()
	fake.TransferTaskStub = nil
	if fake.transferTaskReturnsOnCall == nil {
		fake.transferTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transferTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskBifrost) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.listTasksMutex.RLock()
	defer fake.listTasksMutex.RUnlock()
	fake.transferTaskMutex.RLock()
	defer fake.transferTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTaskBifrost) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handler.TaskBifrost = new(FakeTaskBifrost)
